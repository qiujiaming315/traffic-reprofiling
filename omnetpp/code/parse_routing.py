import numpy as np
import argparse
import os
import re
from pathlib import Path

"""Parse the routing table recorder generated by OMNeT++."""


def parse_routing(rt_table, net_data, option):
    """
    Parse the routing table generated by OMNET++.
    :param rt_table: content of the routing table.
    :param net_data: network data containing node and link information.
    :param option: option parameters.
    """
    nodes, node_names, links = net_data["nodes"], net_data["node_names"], net_data["links"]
    node_names = list(node_names)
    # Variables to keep track of the IP configuration of the network.
    ip_to_host, host_to_gate = list(), dict()
    interface_to_node = [list() for _ in range(len(nodes))]
    # Loop through the links and collect the information assuming default IP configuration.
    for link in links:
        src, dest = link[0], link[1]
        src_type, dest_type = nodes[src, 0], nodes[dest, 0]
        # Map link layer interface to the connected node.
        interface_to_node[src].append(dest)
        interface_to_node[dest].append(src)
        link_type = src_type + dest_type
        assert link_type != 0, "Hosts should not directly connect to each other."
        if link_type == 1:
            host_idx = src if src_type == 0 else dest
            gate_idx = src if src_type == 1 else dest
            # Map IP address to host.
            ip_to_host.append(host_idx)
            # Map gate router to its host(s).
            host_to_gate[host_idx] = gate_idx
    # Parse the simulator generated routing table recorder.
    routing_table = dict()
    for record in rt_table:
        items = record.strip().split()
        record_type = items[0]
        # Only look at routing table updates.
        if record_type == "+R":
            node_name = items[3].split('.')[-1]
            node_idx = node_names.index(node_name)
            node_type = nodes[node_idx, 0]
            dest_ip, interface = items[5], items[7]
            interface_idx = int(re.findall(r'\d+', interface)[-1])
            # Only look at routes that start from routers and go to end hosts.
            if node_type == 1 and dest_ip.startswith("192.168"):
                dest_host = ip_to_host[int(dest_ip.split('.')[2])]
                routing_table[(node_idx, dest_host)] = interface_to_node[node_idx][interface_idx]
    # Use the routing table to collect all the routes between each pair of end hosts.
    routes, route_idx = dict(), 0
    hosts = np.arange(len(nodes))[nodes[:, 0] == 0]
    for src in hosts:
        for dest in hosts:
            if src != dest:
                next_node = src_gate = host_to_gate[src]
                route = [src, src_gate]
                # Keep tracing the routing table until reaching the destination.
                while next_node != dest:
                    next_node = routing_table[(next_node, dest)]
                    route.append(next_node)
                routes[f"route{route_idx}"] = route
                route_idx += 1
    # Save the routes to the specified directory.
    np.savez(os.path.join(option.out, option.routing_name + ".npz"), **routes)
    return


def main(opts):
    # Load the routing table recorder.
    routing_table = open(opts.routing_table, "r").readlines()
    # Load the network data.
    network_data = np.load(opts.net)
    # Create the directory to save the routing table.
    Path(opts.out).mkdir(parents=True, exist_ok=True)
    # Compose the ned file.
    parse_routing(routing_table, network_data, opts)
    return


def getargs():
    """Parse command line arguments."""

    args = argparse.ArgumentParser()
    args.add_argument('net', help="Path to the input npz file describing network nodes and links.")
    args.add_argument('routing_table', help="Path to the routing table recorder generated by OMNeT++.")
    args.add_argument('out', help="Directory to save the parsed routing table.")
    args.add_argument('--routing_name', type=str, default="test", help="Name of the parsed routing table.")
    return args.parse_args()


if __name__ == "__main__":
    main(getargs())
